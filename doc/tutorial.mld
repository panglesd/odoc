{0 Tutorial}

This tutorial will guide you through how to write documentation for your
library!

Good documentation is crucial for users of a library. Even though the OCaml type
system can say a lot about how a function work, this is often not sufficient. It
is often vey helpful to have access to a nicely written introduction to
libraries, modules that your library provide, and to have example or tutorials.

This is especially true as {:ocaml.org} generates the documentation of every
package published on opam's main repository: the documentation of a package is
now very easily browsable, without the need to download the package!

In this tutorial, we will cover how to add documentation to an existing
interface, how to write an index page for your package, add a standalone page to
it, and generate the documentation locally to check if it looks right!

{1 Generating documentation}

Suppose we have the following API in the [dict.mli] file:

{[
  type t

  val get : string -> t -> string

  val add : string -> string -> t -> t
]}

Odoc is able to generate a document from this API, as HTML, Latex or
manpage. See the rendered version of it! {!TODO}.  The information in this case
correspond closely to what is inside the mli file, rendered in html, but it also
has some nice additions! For instance, clicking on [t] in the signature of [get]
and [add] will bring you to the definition of [t].

Another advantage of looking at the API through the pages generated by [odoc]
rather than directly through the [mli] files, is that [odoc] will do all
required computation to display the signature explicitely. For instance, given
the following signature:

{[
  module Dict : sig
    type key

    val get : key -> string
  end

  module StringDict : sig
    include Dict with type key = string
  end
]}

will compute and display the explicit signature of [StringDict], as can be seen
here! {!TODO}

{2 Driving [odoc]}

[odoc] generates documentation from OCaml compilation units. It takes as input
an artefact of the compilation, to benefit from OCaml's work. For the same
reasons as OCaml's compilation, whenever the project is separated in several
files, the calls to [odoc] needs to be made in the right order and with the
right options. Just like for OCaml's compilation, [dune] is a good option to
drive [odoc] and compile the doc.

{[
  # Creating a new project to test documentation generation
  $ dune init proj --kind lib my_new_project
  $ cd my_new_project

  # Creating a file in the project
  $ echo "let x = 5\n" > lib/my_new_project.ml

  # Generating the documentation
  $ dune build @doc

  # Visualizing the documentation
  $ xdg-open _build/default/_doc/_html/index.html
]}

On any [dune]-driven project, [dune build @doc] is the only command needed to
build the documentation. The doc will live in
[_build/default/_doc/_html/index.html], and won't be opened by this command: you
need to open the generated file yourself.

There are other drivers in the wild: [odig] which generates documentation for
your whole switch, and combines more information and [voodoo] which drives
[odoc] for ocaml.org. You can also run [dune build @doc-new] to make [dune]
generate the documentation for your project and your whole switch.

{1 Documenting an API}

While having the interface of your library generated and expanded automatically
is nice, it is often not informative enough. For instance, in [val sub : string
-> from:int -> to:int -> string] you don't know:

- If the bounds are inclusive or exclusive,
- What happens when invalid input is given

Fortunately, OCaml allows to {e attach} documentation strings to your
interfaces:

{[
  val sub : string -> from:int -> to:int -> string
  (** [sub s ~from ~to_] evaluates to the substring in range [from] (inclusive) to
      [to] (exclusive).  *)
]}

Odoc will nicely render those comments attached to the relevant item, as you can
see {{!TODO}here}!

Docstrings can be associated to any items (values, types) but also to
constructors, record fields, or as standalone comments! For the list of
supported attachment point, see the OCaml manual.

You might have noticed that the documentation comment associated to the [sub]
value above contains some formatting markup. This markup is the [odoc] language,
that we are going to overview now!

{1 The odoc markup}

The odoc markup is a simple markup to some formatting to the documentation:
title, emphasis, links, ... It borrows some properties of light markup, but also
contains a heavier syntax for explicit nesting. For a quick summary, have a look
at the {!cheatsheet}!

{2 The light markup}

Similarly to light markups, simple formatting will look similar seen as source
or as rendered. For instance, to create a new paragraph, just add an empty blank
line to separate them! Similarly, bullet points lists are generated using [-] at
the beginning of lines:

{[
  This is a paragraph
  that spans two lines in the source.

  This is another paragraph!

  - Bullet points lists are made using dashes.
  - Just like in real life!
]}

{2 The heavier part}

However, odoc also uses symbol to delimit formatted content: mostly curly braces
([{] and [}]) and square brackets ([\[] and [\]]). The equivalent of [XML]'s
[<tag>content</tag>] in odoc would be: [{tag content}], where [tag] can be:

- [e] for {e emphasized} content: [{e emphasized content}]
- [b] for {b bold} content: [{b bold content}]
- [i] for {i italic} content: [{i italic content}]
- [ul] and [li] for explicit unnumbered list: [{ul {li item 1} {li item2}}]
- [1], [2], [3], [4], [5] for titles: [{1 Iterators}]
- [m] for inline math and [math] for display math: [{m \sqrt 2}]
- [:] for links, and [!] for references: [{:http://www.example.com}]
- [table], [tr], [td], [th] for tables,
- ...

See the reference {!TODO} for the list of supported tags and how they should be nested!

In addition to curly braces, square brackets delimit code spans ([(** If [x] is negative, then returns an error *)]), and [{[ content ]}] delimit code blocks

{delim@text[
  (**
    Here is an example:

    {[
      let map f = function
        | Some x -> Some (f x)
        | None -> None
    ]}
  *)
]delim}

{2 References}

One of the most powerful feature from odoc is to be able to make cross
references between various parts of your documentation. For instance, a simple
[{!String.sub}] will be rendered as {!String.sub}.

The syntax for references is simply [{!ref}] where [ref] follows the syntax for
references, or [{{!ref}replacement text}] if you want the text link and target
to be different. We still need to see the syntax for [ref]!

{1 Standalone pages}

{1 A complete example}

We will start with some setting: the library that you have written, and want to
add documentation.

{[
  let 
]}